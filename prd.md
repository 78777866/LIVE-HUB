# LiveHub Implementation Plan

## Overview

LiveHub enables instant live previews of GitHub repositories directly in the browser using WebContainers. Users authenticate with GitHub, select any Node.js-based repository, and watch it run instantly without local setup. The entire application runs client-side with zero backend infrastructure costs.

**Core Value:** Bridge the gap between "code generated by AI" and "code experienced by humans" instantly.

## Current State Analysis

**Repository:** live-preview-complye
**Location:** `/workspace/cmh8rk46k00vqtmi34lk57odi/live-preview-complye`
**Branch:** main
**Status:** Fresh Git repository with only initialization files

**Existing files:**

- `.git/` - Git repository metadata
- `.gitignore` - Configured for Node.js/Next.js/TypeScript projects (lines 1-XX covering node\_modules, .next, .env, etc.)
- `README.md` - Empty placeholder with repo name only

**What needs to be built:**
Everything. This is a complete greenfield implementation of the LiveHub product.

## Desired End State

A fully functional Next.js application where users can:

1. Log in with GitHub OAuth (read-only repo access)
2. Browse and select their GitHub repositories
3. Choose a branch to preview
4. Click "Run Preview" to spin up a WebContainer
5. See live build logs streaming in real-time
6. View the running application in an embedded iframe
7. Switch between repos/branches seamlessly
8. Return to their last viewed repo automatically (localStorage)

**Verification criteria:**

- User can authenticate and see their GitHub repos
- WebContainer successfully runs `npm install && npm run dev` for supported frameworks
- Live preview iframe displays the running application
- Build logs stream to console in real-time
- All functionality works entirely client-side (no backend required)
- Application deploys successfully to Vercel

---

## Repository: live-preview-complye

## Tech Stack & Dependencies

### Core Framework

**Next.js 14+ with App Router**

- TypeScript for type safety
- React 18+ for UI components
- Tailwind CSS for styling

### Key Dependencies

**Runtime & GitHub Integration:**

- `@webcontainer/api` - StackBlitz WebContainers SDK for in-browser Node.js execution
- `@octokit/rest` - GitHub REST API client
- `@octokit/auth-oauth-app` - GitHub OAuth authentication

**UI & Developer Experience:**

- `tailwindcss` - Utility-first CSS framework
- `lucide-react` or `@heroicons/react` - Icon library
- `clsx` or `class-variance-authority` - Conditional class utilities

### Project Structure

```
live-preview-complye/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ layout.tsx          # Root layout
â”‚   â”‚   â”œâ”€â”€ page.tsx            # Landing/login page
â”‚   â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx        # Main dashboard with preview
â”‚   â”‚   â””â”€â”€ api/
â”‚   â”‚       â””â”€â”€ auth/
â”‚   â”‚           â””â”€â”€ callback/
â”‚   â”‚               â””â”€â”€ route.ts # GitHub OAuth callback
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ AuthButton.tsx      # GitHub login button
â”‚   â”‚   â”œâ”€â”€ RepoSelector.tsx    # Repository dropdown/search
â”‚   â”‚   â”œâ”€â”€ BranchSelector.tsx  # Branch selection
â”‚   â”‚   â”œâ”€â”€ ConsoleLog.tsx      # Build logs display
â”‚   â”‚   â”œâ”€â”€ PreviewFrame.tsx    # Iframe for live preview
â”‚   â”‚   â””â”€â”€ Layout/
â”‚   â”‚       â””â”€â”€ DashboardLayout.tsx # Dashboard layout wrapper
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ github.ts           # GitHub API utilities
â”‚   â”‚   â”œâ”€â”€ webcontainer.ts     # WebContainer management
â”‚   â”‚   â”œâ”€â”€ framework-detector.ts # Detect project framework
â”‚   â”‚   â””â”€â”€ storage.ts          # localStorage utilities
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â””â”€â”€ index.ts            # TypeScript type definitions
â”‚   â””â”€â”€ hooks/
â”‚       â”œâ”€â”€ useGitHubAuth.ts    # GitHub authentication hook
â”‚       â”œâ”€â”€ useWebContainer.ts  # WebContainer lifecycle hook
â”‚       â””â”€â”€ useRepoData.ts      # Fetch/cache repo data
â”œâ”€â”€ public/                      # Static assets
â”œâ”€â”€ .env.local                   # Environment variables (git-ignored)
â”œâ”€â”€ next.config.js              # Next.js configuration
â”œâ”€â”€ tailwind.config.ts          # Tailwind configuration
â”œâ”€â”€ tsconfig.json               # TypeScript configuration
â””â”€â”€ package.json                # Dependencies & scripts
```

---

## Implementation Sections

### 1. Project Initialization & Configuration

**Repository Location:** `/workspace/cmh8rk46k00vqtmi34lk57odi/live-preview-complye`

#### Initial Project Setup

**Step 1: Initialize Next.js Application**

Create new Next.js project with TypeScript and Tailwind CSS:

- Use create-next-app with TypeScript template
- Enable App Router (Next.js 14+)
- Enable Tailwind CSS
- Enable ESLint
- Use src/ directory structure

**Command to run:**

```bash
npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir --use-npm
```

Answer prompts:

- TypeScript: Yes
- ESLint: Yes
- Tailwind CSS: Yes
- src/ directory: Yes
- App Router: Yes
- Import alias: @ (default)

#### Dependencies to Install

**File: package.json** (will be created/updated)

**Core dependencies:**

```json
{
  "dependencies": {
    "next": "^14.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "@webcontainer/api": "^1.1.9",
    "@octokit/auth-oauth-device": "^6.0.0",
    "@octokit/rest": "^20.0.0",
    "lucide-react": "^0.300.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "typescript": "^5.0.0",
    "tailwindcss": "^3.3.0",
    "postcss": "^8.4.31",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.0.0",
    "eslint-config-next": "^14.0.0"
  }
}
```

**Install commands:**

```bash
npm install @webcontainer/api
npm install @octokit/auth-oauth-device @octokit/rest
npm install lucide-react
```

#### Configuration Files

**File: tsconfig.json** (created by create-next-app, verify settings)

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

**File: tailwind.config.ts** (created by create-next-app, customize if needed)

```typescript
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        // Can add custom colors here if needed
      },
    },
  },
  plugins: [],
}
export default config
```

**File: next.config.js** (create in root directory)

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,

  // Required headers for WebContainers
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'Cross-Origin-Embedder-Policy',
            value: 'require-corp',
          },
          {
            key: 'Cross-Origin-Opener-Policy',
            value: 'same-origin',
          },
        ],
      },
    ];
  },

  // Allow GitHub avatars
  images: {
    domains: ['avatars.githubusercontent.com'],
  },
};

module.exports = nextConfig;
```

**File: .env.local** (create in root, git-ignored)

```
NEXT_PUBLIC_GITHUB_CLIENT_ID=your_github_client_id_here
```

**Note:** This file is already in .gitignore, never commit it to the repository.

**File: .env.example** (create in root, committed to git)

```
NEXT_PUBLIC_GITHUB_CLIENT_ID=
```

**Purpose:** Template for other developers to know which env vars are needed.

#### Initial File Structure Creation

**Create directory structure:**

```
src/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ layout.tsx (created by create-next-app)
â”‚   â”œâ”€â”€ page.tsx (created by create-next-app, will be modified)
â”‚   â”œâ”€â”€ globals.css (created by create-next-app)
â”‚   â””â”€â”€ dashboard/
â”‚       â””â”€â”€ page.tsx (create new)
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ AuthButton.tsx (create new)
â”‚   â”œâ”€â”€ RepoSelector.tsx (create new)
â”‚   â”œâ”€â”€ BranchSelector.tsx (create new)
â”‚   â”œâ”€â”€ ConsoleLog.tsx (create new)
â”‚   â”œâ”€â”€ PreviewFrame.tsx (create new)
â”‚   â””â”€â”€ Layout/
â”‚       â””â”€â”€ DashboardLayout.tsx (create new)
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useGitHubAuth.ts (create new)
â”‚   â”œâ”€â”€ useRepoData.ts (create new)
â”‚   â””â”€â”€ useWebContainer.ts (create new)
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ github.ts (create new)
â”‚   â”œâ”€â”€ webcontainer.ts (create new)
â”‚   â”œâ”€â”€ framework-detector.ts (create new)
â”‚   â””â”€â”€ storage.ts (create new)
â””â”€â”€ types/
    â””â”€â”€ index.ts (create new)
```

**Files to create as empty/skeleton initially:**

- All component files: Export empty functional components with proper TypeScript typing
- All hook files: Export empty hooks with proper return types
- All lib files: Export placeholder functions with proper signatures
- types/index.ts: Define all TypeScript interfaces

**File: src/app/globals.css** (update with Tailwind directives)

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom global styles */
body {
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code, pre {
  font-family: 'Monaco', 'Courier New', monospace;
}

/* Scrollbar styling for console logs */
.console-scrollbar::-webkit-scrollbar {
  width: 8px;
}

.console-scrollbar::-webkit-scrollbar-track {
  background: #f1f1f1;
}

.console-scrollbar::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}

.console-scrollbar::-webkit-scrollbar-thumb:hover {
  background: #555;
}
```

#### ESLint Configuration

**File: .eslintrc.json** (created by create-next-app, verify settings)

```json
{
  "extends": "next/core-web-vitals",
  "rules": {
    "react/no-unescaped-entities": "off",
    "@next/next/no-page-custom-font": "off"
  }
}
```

#### Git Configuration

**File: .gitignore** (already exists, verify it includes:)

```
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
```

#### Package.json Scripts

**Verify scripts section in package.json:**

```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  }
}
```

#### README Update

**File: README.md** (update with project information)

```markdown
# LiveHub

Instant Live Previews from GitHub â€” No Setup, No Cost.

## Overview
LiveHub allows you to authenticate with GitHub, select any Node.js-based repository, and watch it run live in your browser using StackBlitz WebContainers. No local setup required.

## Tech Stack
- **Frontend:** Next.js 14 with TypeScript
- **Runtime:** StackBlitz WebContainers
- **Auth:** GitHub OAuth Device Flow
- **API:** GitHub REST API via Octokit
- **Deployment:** Vercel

## Getting Started

### Prerequisites
- Node.js 18+ installed
- GitHub account
- GitHub OAuth App (for authentication)

### Installation

1. Clone the repository
2. Install dependencies:
   ```bash
   npm install
```

3. Create `.env.local` file:

```
   NEXT_PUBLIC_GITHUB_CLIENT_ID=your_github_client_id
```

4. Run development server:

```bash
   npm run dev
```

5. Open [http://localhost:3000](http://localhost:3000)

### GitHub OAuth App Setup

1. Go to GitHub Settings â†’ Developer Settings â†’ OAuth Apps
2. Create new OAuth App:

- Application name: LiveHub
- Homepage URL: http://localhost:3000 (for development)
- Authorization callback URL: Not required for device flow

3. Copy the Client ID to your `.env.local` file

## Project Structure

- `src/app/` - Next.js pages and layouts
- `src/components/` - React components
- `src/hooks/` - Custom React hooks
- `src/lib/` - Utility functions and integrations
- `src/types/` - TypeScript type definitions

## Development

### Building for Production

```bash
npm run build
npm start
```

### Linting

```bash
npm run lint
```

## Deployment

Deploy to Vercel:

1. Connect GitHub repository to Vercel
2. Add `NEXT_PUBLIC_GITHUB_CLIENT_ID` environment variable
3. Deploy

Vercel will automatically detect Next.js and configure build settings.

## Browser Compatibility

WebContainers require:

- Chrome 84+ or Edge 84+
- SharedArrayBuffer support enabled

Safari and Firefox are not currently supported.

## License

MIT

## Credits

Built with [StackBlitz WebContainers](https://webcontainers.io)

```
#### Verification Steps After Setup

**Run these commands to verify setup:**
```bash
# Install dependencies
npm install

# Check for TypeScript errors
npx tsc --noEmit

# Run linter
npm run lint

# Try building
npm run build

# Run dev server
npm run dev
```

**Expected outcomes:**

- No TypeScript errors
- No ESLint errors
- Build succeeds
- Dev server starts on http://localhost:3000
- Default Next.js page loads

**Initial commit message:**

```
Initial project setup

- Initialize Next.js 14 with TypeScript and Tailwind
- Add WebContainer and Octokit dependencies
- Configure COOP/COEP headers for WebContainers
- Create project structure and directories
- Add environment variable configuration
```

### 2. GitHub OAuth Authentication

**Strategy:** GitHub OAuth Device Flow (no callback URL required, fully client-side friendly)

**Dependencies:**

- `@octokit/auth-oauth-device` - Device flow authentication
- `@octokit/rest` - GitHub API client

#### Authentication Flow

**Step 1: Initiate Device Flow**

- User clicks "Login with GitHub" button on landing page (src/app/page.tsx)
- Call GitHub device flow initiation endpoint
- Receive device code and user code from GitHub
- Display user code prominently to user
- Show "Verify on GitHub" button that opens verification URL

**Step 2: User Verification**

- User clicks button, opens GitHub verification page in new tab
- GitHub shows: "Enter code: XXXX-XXXX"
- User enters the code shown in LiveHub
- User authorizes LiveHub with scopes: `repo` (read-only access)

**Step 3: Poll for Token**

- While user is verifying, LiveHub polls GitHub token endpoint every 5 seconds
- Maximum 20 polling attempts (100 seconds total timeout)
- On success: Receive access token
- Store token in localStorage (key: "github\_token")
- Redirect to /dashboard

**Step 4: Validate Token on Load**

- On app initialization, check if token exists in localStorage
- Validate token by calling GitHub API: GET /user
- If valid: User is authenticated, load dashboard
- If invalid/expired: Clear token, redirect to login page

#### Implementation Files

**File: src/hooks/useGitHubAuth.ts** (new file)
**Purpose:** Manage GitHub authentication state and device flow

**Hook exports:**

- `isAuthenticated` (boolean) - Whether user has valid token
- `user` (GitHubUser | null) - Authenticated user data
- `login()` - Initiates device flow
- `logout()` - Clears token and redirects
- `deviceCode` (string | null) - User code to display during login
- `isPolling` (boolean) - Whether currently polling for token

**Login flow logic:**

1. Call createOAuthDeviceAuth from @octokit/auth-oauth-device
2. Set deviceCode state with user code (format: "XXXX-XXXX")
3. Start polling interval (5 seconds)
4. On token received:

- Store in localStorage
- Fetch user data from GET /user
- Set user state
- Clear polling interval
- Redirect to /dashboard

5. On timeout (20 attempts):

- Clear polling
- Show error: "Authentication timeout. Please try again."

**Logout logic:**

1. Remove "github\_token" from localStorage
2. Clear user state
3. Navigate to "/" (landing page)

**Token validation logic:**

1. On hook mount, check localStorage for "github\_token"
2. If exists, create Octokit instance with token
3. Call GET /user to validate
4. If successful: Set user state
5. If fails (401/403): Clear invalid token, set isAuthenticated = false

**File: src/lib/github.ts** (new file)
**Purpose:** GitHub API utility functions

**Export function: createAuthenticatedOctokit()**

- Reads token from localStorage
- Creates and returns Octokit instance configured with token
- Used throughout app for GitHub API calls

**Export function: validateToken(token: string)**

- Accepts token string
- Attempts GET /user request
- Returns { valid: boolean, user?: GitHubUser }

**File: src/components/AuthButton.tsx** (new file)
**Purpose:** Login/logout button component

**Component behavior:**

- If not authenticated: Shows "Login with GitHub" button (GitHub icon + text)
- If authenticated: Shows user avatar + username + logout button
- On login click: Calls login() from useGitHubAuth hook
- On logout click: Calls logout() from useGitHubAuth hook

**File: src/app/page.tsx** (landing page)
**Purpose:** Login screen

**Page layout:**

- Centered card design
- LiveHub logo and tagline at top
- If not authenticated:
- Shows AuthButton (login state)
- If deviceCode exists: Shows verification instructions
    - "Enter this code on GitHub: [XXXX-XXXX]" (large, copyable text)
    - "Verify on GitHub" button (opens verification URL)
    - Loading spinner with text "Waiting for verification..."
- If authenticated: Automatically redirects to /dashboard

**Verification UI specifications:**

- Device code displayed in monospace font, size 24px, bold
- Click-to-copy functionality on code
- Opens https://github.com/login/device in new tab
- Polling status shows spinner animation
- Timeout shows error message in red

#### Environment Variables

**File: .env.local** (git-ignored)
Required variables:

```
NEXT_PUBLIC_GITHUB_CLIENT_ID=your_github_oauth_app_client_id
```

**GitHub OAuth App Configuration:**

- Create GitHub OAuth App at https://github.com/settings/developers
- Application name: "LiveHub"
- Homepage URL: https://your-vercel-domain.vercel.app (or localhost:3000 for dev)
- Authorization callback URL: Not required for device flow
- Enable device flow: Yes
- Requested scopes: `repo` (read-only repository access)

#### Error Handling

**Invalid/Expired Token:**

- Response: 401 Unauthorized from GitHub API
- Action: Clear token from localStorage, redirect to login
- Message: "Session expired. Please login again."

**Network Errors During Device Flow:**

- Response: Network timeout or GitHub API down
- Action: Stop polling, show retry button
- Message: "Connection failed. Please try again."

**User Denies Authorization:**

- Response: GitHub returns "access\_denied"
- Action: Clear device code, reset to initial state
- Message: "Authorization cancelled. Click login to try again."

**Rate Limit Exceeded:**

- Response: 403 with rate limit headers
- Action: Show error, do not retry automatically
- Message: "GitHub rate limit exceeded. Please try again in X minutes."

#### Security Considerations

- Token stored in localStorage (acceptable for client-side app, no backend alternative)
- Token never logged or exposed in errors
- Only request `repo` scope (read-only access)
- No client secret required for device flow (public client)
- Token validated on every app load
- Automatic logout on token invalidation

### 3. Repository Fetching & Processing

**Strategy:** Download repository as tarball from GitHub, extract in-memory, load into WebContainer

#### Repository List & Selection

**File: src/hooks/useRepoData.ts** (new file)
**Purpose:** Fetch and cache user's GitHub repositories

**Hook exports:**

- `repos` (Repository[] | null) - List of user's repositories
- `loading` (boolean) - Whether fetching repos
- `error` (string | null) - Error message if fetch fails
- `refetch()` - Manually refresh repo list

**Fetch logic:**

1. On mount (when user is authenticated):

- Call GitHub API: GET /user/repos
- Parameters: `sort=updated`, `per_page=100`, `affiliation=owner,collaborator`
- Filter results: Only show repos user has push access to
- Sort by updated\_at descending (most recent first)

2. Store in state
3. Cache in localStorage with key: "github\_repos\_cache" (expire after 5 minutes)

**Repository data structure:**

- id (number) - GitHub repo ID
- name (string) - Repository name
- full\_name (string) - "owner/repo"
- description (string | null) - Repo description
- updated\_at (string) - Last update timestamp
- default\_branch (string) - Default branch name (usually "main" or "master")
- private (boolean) - Whether repo is private

**File: src/components/RepoSelector.tsx** (new file)
**Purpose:** Dropdown to select repository

**Component behavior:**

- Renders searchable dropdown (use native select with datalist or custom component)
- Shows repo full\_name (owner/repo format)
- Shows description as secondary text (gray, smaller)
- On selection: Triggers repo data fetch
- Shows "Select repository..." placeholder when none selected
- Shows "Loading repositories..." when useRepoData is loading
- If error: Shows error message in red below dropdown

**Search functionality:**

- Filter repos by name as user types
- Case-insensitive matching
- Show max 50 results at a time (pagination for large lists)

#### Branch Selection

**File: src/components/BranchSelector.tsx** (new file)
**Purpose:** Dropdown to select branch

**Component behavior:**

- Disabled until repository is selected
- On repo selection: Automatically fetch branches
- Call GitHub API: GET /repos/{owner}/{repo}/branches
- Returns list of branches with names
- Default selection: repository's default\_branch
- Shows "Loading branches..." while fetching
- Dropdown shows branch name only (no additional data)

**Branch data structure:**

- name (string) - Branch name
- commit.sha (string) - Latest commit SHA (used for tarball download)

#### Tarball Download & Extraction

**File: src/lib/github.ts** (add functions)

**Export function: downloadRepoTarball(owner, repo, ref)**
**Purpose:** Download repository tarball from GitHub

**Parameters:**

- owner (string) - Repository owner
- repo (string) - Repository name
- ref (string) - Branch name or commit SHA

**Implementation:**

1. Construct tarball URL: `https://api.github.com/repos/{owner}/{repo}/tarball/{ref}`
2. Fetch with authenticated Octokit instance
3. Set Accept header: "application/vnd.github.v3+json"
4. Download returns binary tarball data (ArrayBuffer)
5. Return ArrayBuffer for extraction

**Error handling:**

- 404: Repository or branch not found â†’ "Repository or branch not found"
- 403: No access or rate limited â†’ "Access denied or rate limit exceeded"
- Network error â†’ "Failed to download repository"

**Export function: extractTarball(tarballData)**
**Purpose:** Extract tarball and convert to file structure for WebContainer

**Parameters:**

- tarballData (ArrayBuffer) - Raw tarball binary data

**Implementation:**

1. Use a tarball extraction library:

- Recommended: `@gfx/zopfli` or pure JS tar library like `js-untar`
- Parse tar format, decompress gzip

2. Extract all files into memory
3. Build file tree structure:

- Format: `{ [filepath]: { file: { contents: string } } }`
- Example: `{ "package.json": { file: { contents: "..." } }, "src/index.js": { directory: { "index.js": { file: { contents: "..." } } } } }`

4. Remove root directory prefix (GitHub adds repo-name-sha prefix)
5. Return file tree object compatible with WebContainer API

**File structure format:**

```
{
  "package.json": {
    file: {
      contents: "file contents as string"
    }
  },
  "src": {
    directory: {
      "index.js": {
        file: {
          contents: "file contents"
        }
      }
    }
  }
}
```

**Binary files:**

- Skip binary files (images, videos, etc.) for MVP
- Only include text-based source files
- Check file extensions: .js, .ts, .tsx, .jsx, .json, .css, .html, .md, .txt, .env, .gitignore
- Max file size: 1MB per file (skip larger files)

#### Framework Detection

**File: src/lib/framework-detector.ts** (new file)
**Purpose:** Detect project framework and determine run commands

**Export function: detectFramework(fileTree)**
**Purpose:** Analyze file structure and package.json to identify framework

**Parameters:**

- fileTree (object) - Extracted file structure

**Detection logic:**

1. Check if package.json exists

- If missing: Return { framework: "unknown", error: "No package.json found" }

2. Parse package.json contents
3. Check dependencies and devDependencies for framework signatures:

**Framework detection rules (check in order):**

1. **Next.js**

- Dependency: "next"
- Install command: "npm install"
- Dev command: "npm run dev"
- Expected port: 3000

2. **Vite (React/Vue/Svelte)**

- Dependency: "vite"
- Install command: "npm install"
- Dev command: "npm run dev"
- Expected port: 5173

3. **Create React App**

- Dependency: "react-scripts"
- Install command: "npm install"
- Dev command: "npm start"
- Expected port: 3000

4. **Vue CLI**

- Dependency: "@vue/cli-service"
- Install command: "npm install"
- Dev command: "npm run serve"
- Expected port: 8080

5. **Angular**

- Dependency: "@angular/core"
- Install command: "npm install"
- Dev command: "npm start"
- Expected port: 4200

6. **Astro**

- Dependency: "astro"
- Install command: "npm install"
- Dev command: "npm run dev"
- Expected port: 4321

7. **SvelteKit**

- Dependency: "@sveltejs/kit"
- Install command: "npm install"
- Dev command: "npm run dev"
- Expected port: 5173

8. **Remix**

- Dependency: "@remix-run/react"
- Install command: "npm install"
- Dev command: "npm run dev"
- Expected port: 3000

9. **Generic Node.js**

- Has package.json but no recognized framework
- Check for "dev" or "start" script in package.json
- Install command: "npm install"
- Dev command: Read from package.json scripts
- Expected port: Parse from scripts or default 3000

**Return format:**

```
{
  framework: "nextjs" | "vite" | "cra" | "vue" | "angular" | "astro" | "sveltekit" | "remix" | "node" | "unknown",
  installCommand: string,
  devCommand: string,
  expectedPort: number,
  packageManager: "npm" | "yarn" | "pnpm" (detect from lock files)
}
```

**Package manager detection:**

- If "pnpm-lock.yaml" exists: Use pnpm
- If "yarn.lock" exists: Use yarn
- If "package-lock.json" exists: Use npm
- Default: npm

#### Data Flow Integration

**File: src/app/dashboard/page.tsx** (main dashboard)

**State management:**

- `selectedRepo` (Repository | null) - Currently selected repository
- `selectedBranch` (string | null) - Currently selected branch
- `fileTree` (object | null) - Extracted repository file structure
- `frameworkInfo` (FrameworkInfo | null) - Detected framework details
- `isDownloading` (boolean) - Whether downloading/extracting repo
- `downloadError` (string | null) - Download error message

**User flow on dashboard:**

1. User selects repo from RepoSelector â†’ Sets selectedRepo
2. BranchSelector auto-loads branches â†’ User selects branch â†’ Sets selectedBranch
3. User clicks "Run Preview" button:

- Set isDownloading = true
- Call downloadRepoTarball(repo.owner, repo.name, branch)
- Call extractTarball(tarballData) â†’ Get fileTree
- Call detectFramework(fileTree) â†’ Get frameworkInfo
- If framework = "unknown": Show error "Unsupported project type"
- If success: Pass fileTree and frameworkInfo to WebContainer
- Set isDownloading = false

**Loading states:**

- During download: Show progress message "Downloading repository..."
- During extraction: Show progress message "Extracting files..."
- During detection: Show progress message "Detecting framework..."

**Error states:**

- Download fails: Show error below Run button, keep button enabled for retry
- Extraction fails: Show error "Failed to extract repository files"
- Detection fails: Show warning "Could not detect framework. Manual configuration needed." (future enhancement)

#### localStorage Persistence

**File: src/lib/storage.ts** (new file)
**Purpose:** Manage localStorage for app state

**Export function: saveLastRepo(repo, branch)**

- Saves selected repo and branch to localStorage
- Key: "livehub\_last\_repo"
- Value: JSON string `{ repo: {...}, branch: "main" }`

**Export function: loadLastRepo()**

- Loads last repo/branch from localStorage
- Returns null if not found or expired (24 hour expiration)
- Auto-populate repo and branch selectors on dashboard load

**Export function: clearLastRepo()**

- Removes saved repo from localStorage
- Called on logout

### 4. WebContainer Integration

**Strategy:** Boot WebContainer instance, mount file system, run install/dev commands, stream logs with 100ms throttle

**Dependency:** `@webcontainer/api` - StackBlitz WebContainers SDK

#### WebContainer Lifecycle Management

**File: src/hooks/useWebContainer.ts** (new file)
**Purpose:** Manage WebContainer instance lifecycle and execution

**Hook exports:**

- `container` (WebContainer | null) - Active WebContainer instance
- `isBooting` (boolean) - Whether WebContainer is initializing
- `isInstalling` (boolean) - Whether npm install is running
- `isRunning` (boolean) - Whether dev server is running
- `logs` (LogEntry[]) - Array of log messages
- `previewUrl` (string | null) - URL for iframe preview
- `error` (string | null) - Error message if execution fails
- `startPreview(fileTree, frameworkInfo)` - Main function to start preview
- `stopPreview()` - Stop container and clean up

**WebContainer initialization:**

1. On first call to startPreview():

- Call WebContainer.boot() (only once per app session)
- Set isBooting = true
- Wait for boot completion (typically 2-5 seconds)
- Store instance in state
- Set isBooting = false

2. Reuse same instance for subsequent previews (don't re-boot)

**File system mounting:**

1. After boot, call container.mount(fileTree)
2. fileTree is the extracted repository structure from tarball
3. WebContainer creates virtual file system with all files
4. Verify mount success before proceeding

**Command execution sequence:**

**Step 1: Install Dependencies**

1. Set isInstalling = true
2. Create install process:

- Command: frameworkInfo.installCommand (e.g., "npm install")
- Use container.spawn(packageManager, ['install'])

3. Stream stdout and stderr to logs
4. Wait for process exit
5. Check exit code:

- Exit 0: Success, proceed to dev server
- Non-zero: Error, show "Installation failed" and stop

6. Set isInstalling = false

**Step 2: Start Dev Server**

1. Set isRunning = true
2. Parse dev command (e.g., "npm run dev" â†’ spawn('npm', ['run', 'dev']))
3. Create dev process using container.spawn()
4. Stream stdout and stderr to logs
5. Listen for server ready signals:

- "ready - started server" (Next.js)
- "Local: http://localhost:" (Vite)
- "Compiled successfully" (CRA)
- "server running at" (generic)

6. Once detected, get server URL from WebContainer
7. Set previewUrl state

**Log streaming implementation:**

**LogEntry data structure:**

```
{
  id: string (timestamp + random),
  timestamp: Date,
  type: "stdout" | "stderr" | "system",
  message: string,
  source: "install" | "dev"
}
```

**Streaming logic:**

1. Listen to process.output stream (ReadableStream)
2. Collect chunks in buffer
3. Throttle updates to logs state: batch updates every 100ms
4. Append new logs to existing array (max 1000 entries, remove oldest)
5. Auto-scroll console to bottom when new logs arrive

**Throttle implementation:**

- Use setTimeout with 100ms delay
- Accumulate log entries in temp buffer during delay
- After 100ms, flush buffer to state in single update
- Prevents excessive re-renders while maintaining real-time feel

**Preview URL handling:**

**Server detection:**

1. Monitor dev server logs for port binding messages
2. Extract port number from logs
3. Call container.on('server-ready', (port, url) => {...})
4. WebContainer provides preview URL automatically
5. Set previewUrl state with URL

**URL format:**

- WebContainer provides URL like: "https://random-id.webcontainer.io"
- This URL is CORS-enabled and iframe-safe
- No additional configuration needed

**Stop and cleanup:**

1. On stopPreview() call:

- Kill install process (if running)
- Kill dev server process
- Clear logs array
- Reset all state (isInstalling, isRunning, previewUrl)
- Keep container instance alive (don't dispose, reuse for next preview)

2. On component unmount:

- Call stopPreview()
- Dispose WebContainer: container.teardown()

#### WebContainer Error Handling

**Boot failures:**

- Error: WebContainer.boot() fails
- Cause: Browser not supported (needs Chrome/Edge with SharedArrayBuffer)
- Action: Show error "Your browser doesn't support WebContainers. Please use Chrome, Edge, or Brave."
- Recovery: None, browser incompatible

**Mount failures:**

- Error: container.mount() throws error
- Cause: Invalid file structure or corrupted tarball
- Action: Show error "Failed to load repository files"
- Recovery: User can retry with different branch

**Install failures:**

- Error: npm install exits with non-zero code
- Cause: Missing dependencies, network issues, incompatible Node version
- Action: Show full error logs, highlight last error in red
- Display: "Installation failed. Check logs for details."
- Recovery: Retry button available, or user can switch branches

**Dev server failures:**

- Error: Dev server exits immediately or crashes
- Cause: Port already in use, missing env vars, code errors
- Action: Show error logs, keep console visible
- Display: "Dev server failed to start. Check logs."
- Recovery: Retry button available

**Timeout handling:**

- Install timeout: 2 minutes maximum
- If install runs longer: Show warning "Installation taking longer than expected..."
- After 2 min: Kill process, show error "Installation timed out"
- Dev server start timeout: 1 minute maximum
- If server doesn't emit ready signal within 1 min: Show warning
- User can still check logs to see if server actually started

**Memory limits:**

- WebContainer has browser memory limits (\~2GB typical)
- If exceeded: WebContainer throws error
- Action: Show "Out of memory. Try a smaller repository."
- Recovery: None for current preview, user must select different repo

#### Preview Frame Component

**File: src/components/PreviewFrame.tsx** (new file)
**Purpose:** Display live preview in iframe

**Component behavior:**

- Renders iframe element
- src attribute set to previewUrl from useWebContainer hook
- If previewUrl is null: Shows placeholder "Preview will appear here..."
- If isBooting or isInstalling: Shows loading state with spinner
- If isRunning but no previewUrl yet: Shows "Starting server..."
- If error: Shows error message instead of iframe

**Iframe specifications:**

- Width: 100% of container
- Height: 100% of container
- Border: None
- Sandbox attributes: allow-same-origin, allow-scripts, allow-forms, allow-popups, allow-modals
- Title: "Live Preview"
- Loading strategy: Immediate (don't use lazy loading)

**Iframe error handling:**

- If iframe fails to load: Show error overlay
- Network errors: "Preview failed to load"
- CORS errors: Should not occur (WebContainer URLs are CORS-safe)

**Refresh functionality:**

- Add "Refresh Preview" button above iframe
- On click: Reload iframe (set src to itself)
- Useful if app crashes or shows error state

#### Console Log Component

**File: src/components/ConsoleLog.tsx** (new file)
**Purpose:** Display streaming build logs

**Component behavior:**

- Receives logs array from useWebContainer hook
- Displays in monospace font (font-family: 'Monaco', 'Courier New', monospace)
- Each log entry on separate line
- Auto-scroll to bottom when new logs arrive (unless user scrolled up)
- Preserve scroll position if user manually scrolled up

**Log entry formatting:**

- System logs (type: "system"): Gray color (#999)
- Examples: "Booting WebContainer...", "Installing dependencies..."
- Stdout logs (type: "stdout"): Black color (#333)
- Normal command output
- Stderr logs (type: "stderr"): Red color (#d32f2f)
- Error messages and warnings

**Visual features:**

- Line numbers: Optional, shown on left (gray, small font)
- Timestamps: Optional, shown before message (format: "HH:MM:SS")
- Clear logs button: Button at top to clear all logs
- Download logs button: Export logs as .txt file

**Auto-scroll logic:**

1. Track if user has manually scrolled: Compare scrollTop + clientHeight vs scrollHeight
2. If at bottom (within 50px): Auto-scroll on new logs
3. If scrolled up: Don't auto-scroll, show "â†“ New logs" indicator at bottom
4. Clicking indicator scrolls to bottom

**Performance optimization:**

- Use virtualization for large log lists (>500 entries)
- Library: react-window or react-virtualized
- Only render visible log entries
- Prevents DOM performance issues with thousands of logs

#### Integration with Dashboard

**File: src/app/dashboard/page.tsx** (update)

**State flow:**

1. User clicks "Run Preview" button:

- Trigger startPreview(fileTree, frameworkInfo) from useWebContainer

2. useWebContainer manages entire execution:

- Boots container (if needed)
- Mounts files
- Runs install
- Starts dev server
- Streams logs
- Provides preview URL

3. Dashboard components react to state changes:

- ConsoleLog shows logs in real-time
- PreviewFrame shows loading â†’ preview URL
- Run button disabled while running
- Stop button enabled while running

**Stop button:**

- Add "Stop Preview" button next to "Run Preview"
- Only enabled when isInstalling or isRunning is true
- On click: Calls stopPreview()
- Immediately stops processes and clears preview

**Status indicator:**

- Show current status above preview area:
- "Booting..." (isBooting)
- "Installing dependencies..." (isInstalling)
- "Starting server..." (isRunning && !previewUrl)
- "Running" (isRunning && previewUrl)
- "Stopped" (default state)
- Include framework badge: "Next.js" / "Vite" / etc.
- Include branch badge: "main" / branch name

### 5. UI Components & Layout

#### Overall Layout Structure

**Main Dashboard Layout (src/app/dashboard/page.tsx):**

- Split-screen layout: Build logs on left (40% width), live preview on right (60% width)
- Fixed header at top with branding and user info
- Controls bar below header with repo selector, branch selector, and run button
- Main content area fills remaining viewport height

**Layout Specifications:**

**Header Section:**

- Background: Light gray (#f5f5f5)
- Border bottom: 2px solid
- Left side: LiveHub logo/branding with emoji ðŸ§­
- Right side: GitHub username with avatar
- Height: 60px fixed
- Padding: 15px horizontal

**Controls Bar:**

- Background: Light gray (#f5f5f5)
- Border bottom: 2px solid
- Flexbox layout, horizontal alignment
- Contains three elements: Repo dropdown, Branch dropdown, Run button
- Height: Auto (fits content with 15px padding)
- Gap between elements: 15px

**Split Content Area:**

- Fills remaining viewport height (calc(100vh - header - controls))
- Left panel (Console): 40% width
- Right panel (Preview): 60% width
- Divider between panels: 2px solid border
- No resizing (fixed split ratio for MVP)

**Responsive Behavior:**

- Desktop (>1024px): Split screen as described
- Tablet/Mobile (<1024px): Stack vertically - logs on top (300px fixed height), preview below (remaining height)

#### Individual Component Specifications

**File: src/app/layout.tsx** (root layout)
**Purpose:** Global app layout and providers

**Layout content:**

- HTML document structure
- Global CSS imports (Tailwind)
- Font configuration (system fonts)
- Meta tags for SEO and mobile
- No header/navigation (handled per page)

**File: src/app/page.tsx** (landing page)
**Purpose:** Login screen and device flow verification

**Page structure:**

- Full-screen centered container
- Max width: 400px
- Vertical centering with flexbox
- Background: Clean gradient or solid light color

**Content sections:**

1. **Logo and branding**

- LiveHub logo with emoji ðŸ§­
- Tagline: "Instant Live Previews from GitHub â€” No Setup, No Cost."
- Typography: Large heading, smaller subtitle

2. **Authentication section**

- AuthButton component (login/logout state)
- Device verification UI (when deviceCode exists)
- Error messages (red text, centered)

3. **Footer** (optional)

- "Powered by StackBlitz WebContainers"
- GitHub repository link

**File: src/app/dashboard/page.tsx** (main application)
**Purpose:** Dashboard with repo selection and split-screen preview

**Page structure:**

- Full viewport height layout (100vh)
- Three sections: Header (60px), Controls (auto), Content (remaining)
- No scroll on main container (scroll within panels only)

**Header bar:**

- Background: Light gray (#f8f9fa)
- Flexbox: space-between
- Left: Logo "ðŸ§­ LiveHub" (medium size)
- Right: Username with avatar (from GitHub) + logout button
- Border bottom: 1px solid #e5e5e5

**Controls bar:**

- Background: Light gray (#f8f9fa)
- Padding: 16px 20px
- Flexbox layout with gaps
- Three main elements:

1. **Repository selector**

- Label: "Repository" (small, uppercase, gray)
- Dropdown width: 300px
- Search/filter functionality
- Shows repo name and description

2. **Branch selector**

- Label: "Branch" (small, uppercase, gray)
- Dropdown width: 150px
- Disabled until repo selected
- Default to repo's default branch

3. **Action buttons**

- "Run Preview" button (primary, blue)
- "Stop Preview" button (secondary, gray, only when running)
- Loading states with spinner icons

**Content area (split panels):**

- Display: flex
- No scroll on container level
- Left panel (Console): 40% width, min-width 300px
- Right panel (Preview): 60% width, min-width 400px
- Separator: 2px solid border, light gray
- Both panels: Full remaining height

**File: src/components/Layout/DashboardLayout.tsx** (dashboard wrapper)
**Purpose:** Reusable dashboard layout structure

**Component props:**

- children (ReactNode) - Main content area
- user (GitHubUser) - Authenticated user data

**Layout behavior:**

- Renders header with user info
- Renders children in content area
- Handles responsive collapse (mobile stacks vertically)

**File: src/components/AuthButton.tsx** (login/logout button)
**Purpose:** GitHub authentication button

**Component behavior:**

- If not authenticated: Shows GitHub login button
- Icon: GitHub logo (from Lucide React or Heroicons)
- Text: "Continue with GitHub"
- Style: Full width, dark button with white text
- On click: Triggers login flow
- If deviceCode exists (during login): Shows device verification
- Large code display: Monospace font, 24px, copyable
- Verification button: "Verify on GitHub" (opens new tab)
- Loading state: Spinner with "Waiting for verification..."
- Timeout warning after 90 seconds
- If authenticated: Shows user info + logout
- Avatar: GitHub user avatar (32px circle)
- Username: GitHub username
- Logout button: Text link, secondary style
- Layout: Horizontal flex

**File: src/components/RepoSelector.tsx** (repository dropdown)
**Purpose:** Searchable repository selection

**Component props:**

- onSelect: (repo: Repository) => void
- value: Repository | null
- disabled: boolean

**Component features:**

- Custom dropdown (not native select) for better UX
- Search input at top of dropdown
- Repository list with scroll (max height 300px)
- Each item shows:
- Repository full name (owner/repo) - bold
- Description (if exists) - gray, smaller text, truncated
- Last updated - gray, small text, relative time
- Loading state: Skeleton items
- Empty state: "No repositories found"
- Error state: Retry button

**Search functionality:**

- Filters by repository name (case insensitive)
- Highlights matching text
- Clears when dropdown closes
- Shows count: "X of Y repositories"

**File: src/components/BranchSelector.tsx** (branch dropdown)
**Purpose:** Branch selection dropdown

**Component props:**

- repository: Repository | null
- onSelect: (branch: string) => void
- value: string | null
- disabled: boolean

**Component features:**

- Simple native select (fewer options than repos)
- Auto-loads branches when repository changes
- Loading state: Shows "Loading branches..."
- Default selection: repository.default\_branch
- Each option shows branch name only
- Error handling: Shows "Failed to load branches"

**File: src/types/index.ts** (TypeScript definitions)
**Purpose:** Shared type definitions

**Key interfaces:**

```typescript
interface GitHubUser {
  id: number;
  login: string;
  avatar_url: string;
  name: string | null;
  email: string | null;
}

interface Repository {
  id: number;
  name: string;
  full_name: string;
  description: string | null;
  updated_at: string;
  default_branch: string;
  private: boolean;
  owner: {
    login: string;
  };
}

interface Branch {
  name: string;
  commit: {
    sha: string;
  };
}

interface FrameworkInfo {
  framework: "nextjs" | "vite" | "cra" | "vue" | "angular" | "astro" | "sveltekit" | "remix" | "node" | "unknown";
  installCommand: string;
  devCommand: string;
  expectedPort: number;
  packageManager: "npm" | "yarn" | "pnpm";
}

interface LogEntry {
  id: string;
  timestamp: Date;
  type: "stdout" | "stderr" | "system";
  message: string;
  source: "install" | "dev";
}
```

#### Styling and Design System

**Tailwind CSS Configuration:**

- Use Tailwind's default design tokens
- Custom colors (if needed):
- GitHub brand colors for buttons
- Success/error states (green/red)
- Neutral grays for backgrounds

**Component styling approach:**

- Utility-first with Tailwind classes
- Create reusable component classes where needed
- Responsive design: Desktop-first, mobile-friendly
- Dark mode: Not included in MVP (future enhancement)

**Responsive breakpoints:**

- Desktop: â‰¥1024px (split-screen layout)
- Tablet: 768px-1023px (stacked layout, smaller gaps)
- Mobile: <768px (single column, simplified UI)

**Mobile adaptations:**

- Header: Smaller logo, hamburger menu for user actions
- Controls: Stack vertically, full-width dropdowns
- Content: Console on top (200px height), preview below
- Buttons: Larger touch targets (minimum 44px height)

#### Accessibility Considerations

**Keyboard navigation:**

- All interactive elements focusable
- Tab order: Logo â†’ repo selector â†’ branch selector â†’ run button â†’ panels
- Escape key: Close dropdowns
- Enter/Space: Activate buttons and selections

**Screen reader support:**

- Proper ARIA labels on dropdowns and buttons
- Live regions for status updates ("Installing...", "Running...")
- Alt text for loading spinners and status indicators
- Semantic HTML structure (header, main, nav elements)

**Visual accessibility:**

- Color contrast: All text meets WCAG AA standards (4.5:1 minimum)
- Focus indicators: Clear outline on keyboard focus
- Loading states: Both visual and text indicators
- Error states: Icons and text (not color-only)

#### Loading States and Feedback

**Global loading patterns:**

- Skeleton loading for content that's being fetched
- Spinner loading for actions in progress
- Progress bars for longer operations (file downloads)

**Micro-interactions:**

- Button press feedback (slight scale/shadow change)
- Hover states on interactive elements
- Smooth transitions between states (0.2s ease)
- Success feedback: Green checkmark or toast message

**Error handling UI:**

- Inline errors below relevant inputs
- Toast notifications for system-wide errors
- Retry buttons where applicable
- Clear error messages in plain language

### 6. State Management & Persistence

**Strategy:** React hooks for component state, localStorage for persistence, no global state library needed for MVP

#### State Architecture

**Application-level state (no Redux/Context needed):**

- Authentication state: Managed by useGitHubAuth hook
- Repository data: Managed by useRepoData hook
- WebContainer state: Managed by useWebContainer hook
- All state co-located with hooks, passed via props to components

**Why no global state manager:**

- Simple application with linear data flow
- State scoped to specific features (auth, repos, container)
- Hooks provide sufficient state management
- Reduces bundle size and complexity

#### localStorage Usage

**Keys and values:**

1. **`github_token`**

- Value: GitHub access token (string)
- Set: After successful device flow authentication
- Read: On app load to check auth status
- Clear: On logout or token invalidation

2. **`github_repos_cache`**

- Value: JSON stringified repository list with timestamp
- Format: `{ repos: Repository[], cachedAt: number }`
- TTL: 5 minutes (300000ms)
- Set: After fetching repos from GitHub API
- Read: On dashboard load to avoid redundant API calls
- Clear: On cache expiration or logout

3. **`livehub_last_repo`**

- Value: JSON stringified last selected repo and branch
- Format: `{ repo: Repository, branch: string, savedAt: number }`
- TTL: 24 hours
- Set: When user runs preview
- Read: On dashboard load to auto-populate selectors
- Clear: On logout or expiration

**Storage utilities (src/lib/storage.ts):**

- All localStorage access centralized in storage.ts
- Handles JSON serialization/deserialization
- Handles expiration logic
- Graceful fallback if localStorage unavailable (Safari private mode)

#### Data Flow Diagram

**Authentication flow:**

1. User clicks login â†’ useGitHubAuth.login()
2. Device code received â†’ Display to user
3. Token received â†’ Store in localStorage
4. User data fetched â†’ Set user state
5. Redirect to /dashboard

**Preview flow:**

1. Dashboard loads â†’ useGitHubAuth validates token
2. useRepoData fetches repositories â†’ Populate dropdown
3. User selects repo + branch â†’ Update state
4. User clicks "Run Preview" â†’ Trigger download
5. downloadRepoTarball + extractTarball â†’ Get fileTree
6. detectFramework â†’ Get frameworkInfo
7. useWebContainer.startPreview(fileTree, frameworkInfo)
8. WebContainer boots â†’ mounts â†’ installs â†’ runs
9. Logs stream to ConsoleLog component
10. Preview URL set â†’ PreviewFrame displays iframe

#### Error State Management

**Each feature hook manages its own errors:**

- useGitHubAuth: `authError` state for login/token errors
- useRepoData: `error` state for repo fetch errors
- useWebContainer: `error` state for container errors

**Error display strategy:**

- Errors shown inline near relevant UI
- Auth errors: Below login button
- Repo errors: Below repo selector
- Container errors: In console logs + overlay on preview
- Use consistent error styling across app

**Error recovery:**

- All errors include actionable next steps
- Retry buttons where applicable
- Clear error messages in plain language
- No technical jargon or stack traces shown to users

### 7. Error Handling & Edge Cases

#### Comprehensive Error Scenarios

**1. Browser Compatibility**

- **Issue:** WebContainers require Chrome/Edge with SharedArrayBuffer support
- **Detection:** Try WebContainer.boot(), catch error
- **User message:** "Your browser doesn't support WebContainers. Please use Chrome, Edge, or Brave (latest version)."
- **Recovery:** None, show browser recommendations

**2. GitHub Rate Limiting**

- **Issue:** GitHub API has rate limits (60 req/hour unauthenticated, 5000 authenticated)
- **Detection:** GitHub API returns 403 with rate limit headers
- **User message:** "GitHub rate limit exceeded. Try again in [X] minutes."
- **Recovery:** Show countdown timer, allow retry after limit resets
- **Prevention:** Cache repository list, minimize API calls

**3. Large Repositories**

- **Issue:** Tarball > 50MB may fail to download or extract
- **Detection:** Check content-length header before download
- **User message:** "Repository too large (>50MB). Try a smaller project."
- **Recovery:** None for MVP, suggest alternative branch or repo
- **Prevention:** Show warning if repo size known from API

**4. Missing package.json**

- **Issue:** Repository has no package.json (not a Node.js project)
- **Detection:** detectFramework returns "unknown"
- **User message:** "This doesn't appear to be a Node.js project. LiveHub currently supports Node.js frameworks only."
- **Recovery:** None, user selects different repo
- **Prevention:** Could filter repos by language in future

**5. Install Failures**

- **Issue:** npm install fails (missing dependencies, private packages, etc.)
- **Detection:** Install process exits with non-zero code
- **User message:** "Installation failed. Check the console logs for details."
- **Recovery:** Show full error logs, offer retry button
- **Common causes:** Private packages, missing .npmrc, version conflicts

**6. Dev Server Crashes**

- **Issue:** Dev server starts but crashes immediately
- **Detection:** Process exits unexpectedly after starting
- **User message:** "Dev server crashed. Check logs for errors."
- **Recovery:** Logs remain visible, retry button available
- **Common causes:** Port conflicts, environment variable dependencies, code errors

**7. Network Failures**

- **Issue:** No internet connection or GitHub API down
- **Detection:** Fetch errors, timeout errors
- **User message:** "Network error. Check your connection and try again."
- **Recovery:** Retry button, check navigator.onLine status
- **Prevention:** Show offline indicator if navigator.onLine = false

**8. Token Expiration**

- **Issue:** GitHub token expires or is revoked
- **Detection:** API returns 401 Unauthorized
- **User message:** "Session expired. Please log in again."
- **Recovery:** Auto-redirect to login page, clear invalid token
- **Prevention:** Validate token on app load

**9. CORS Issues**

- **Issue:** GitHub API CORS errors (shouldn't occur but edge case)
- **Detection:** Fetch fails with CORS error
- **User message:** "Unable to connect to GitHub. Please try again."
- **Recovery:** Retry, check browser extensions blocking requests
- **Note:** Rare with proper API usage

**10. Monorepo/Workspace Projects**

- **Issue:** Repo uses workspaces/monorepo structure
- **Detection:** Multiple package.json files, workspace config
- **User message:** "Monorepo detected. Specify which workspace to preview." (future feature)
- **Recovery:** For MVP, may fail or run root package.json only
- **Future:** Allow selecting specific workspace

#### Edge Cases

**Empty Repositories:**

- Scenario: Repo has no files
- Handling: Show error "Repository is empty"
- Recovery: User selects different repo

**Branch Deletion:**

- Scenario: Branch deleted after selection
- Handling: Tarball download returns 404
- Recovery: Show error, refresh branch list

**Very Slow Installs:**

- Scenario: Install takes >2 minutes (large dependencies)
- Handling: Show warning "Still installing... this may take a while"
- Recovery: Allow user to stop/cancel, don't hard timeout until 5 minutes

**Binary-Heavy Repos:**

- Scenario: Repo contains many images/videos
- Handling: Skip binary files during extraction
- Effect: App runs but images may be missing
- Note: Source code files are sufficient for most previews

**Environment Variables:**

- Scenario: App requires .env variables to run
- Handling: For MVP, apps run without env vars
- Effect: May cause runtime errors in preview
- Future: Allow users to specify env vars in UI

**Port Conflicts (in WebContainer):**

- Scenario: Multiple projects trying to use same port
- Handling: WebContainer manages virtual ports, shouldn't conflict
- Note: Each WebContainer instance is isolated

**Stopping Mid-Install:**

- Scenario: User clicks stop during npm install
- Handling: Kill install process, clean up, reset state
- Recovery: User can retry immediately

**Switching Repos While Running:**

- Scenario: User selects different repo while preview running
- Handling: Auto-stop current preview, clear state
- Effect: New repo selection disabled until current preview stopped
- Alternative: Show confirmation "Stop current preview to switch repos?"

### 8. Deployment Configuration

#### Vercel Deployment Setup

**Platform:** Vercel (Free Hobby tier)

**Repository Connection:**

- Connect GitHub repository to Vercel
- Auto-deploy on push to main branch
- Preview deployments for pull requests

**Environment Variables (Vercel Dashboard):**

```
NEXT_PUBLIC_GITHUB_CLIENT_ID=<github_oauth_app_client_id>
```

**Build Configuration:**

- Framework Preset: Next.js
- Build Command: `npm run build` (default)
- Output Directory: `.next` (default)
- Install Command: `npm install` (default)
- Node Version: 18.x or higher

**next.config.js Configuration:**

**File: next.config.js** (create in root)

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Enable React strict mode for better development experience
  reactStrictMode: true,

  // Required headers for WebContainers (SharedArrayBuffer support)
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'Cross-Origin-Embedder-Policy',
            value: 'require-corp',
          },
          {
            key: 'Cross-Origin-Opener-Policy',
            value: 'same-origin',
          },
        ],
      },
    ];
  },

  // Allow GitHub images for user avatars
  images: {
    domains: ['avatars.githubusercontent.com'],
  },
};

module.exports = nextConfig;
```

**Critical headers explanation:**

- `Cross-Origin-Embedder-Policy: require-corp` - Required for SharedArrayBuffer
- `Cross-Origin-Opener-Policy: same-origin` - Required for SharedArrayBuffer
- These headers enable WebContainers to work properly

**Vercel-specific optimizations:**

- Automatic HTTPS (SSL)
- CDN caching for static assets
- Automatic image optimization (Next.js Image component)
- Edge network deployment (global)

#### GitHub OAuth App Setup

**Create OAuth App:**

1. Go to GitHub Settings â†’ Developer settings â†’ OAuth Apps
2. Click "New OAuth App"
3. Fill in details:

- Application name: "LiveHub"
- Homepage URL: `https://your-vercel-domain.vercel.app`
- Application description: "Instant live previews from GitHub repositories"
- Authorization callback URL: Not required for device flow (leave blank or use homepage URL)

4. After creation, note the Client ID
5. Add Client ID to Vercel environment variables

**Scopes required:**

- `repo` - Read repository contents (includes public and private repos)
- `user:email` - Read user email address (optional, for user profile)

**Device Flow must be enabled:**

- By default, device flow should be enabled for OAuth Apps
- If issues occur, verify in GitHub App settings

#### DNS and Custom Domain (Optional)

**If using custom domain:**

1. Purchase domain (Namecheap, Cloudflare, etc.)
2. Add domain in Vercel dashboard
3. Update DNS records as instructed by Vercel
4. Update GitHub OAuth App homepage URL to custom domain
5. Update NEXT\_PUBLIC\_GITHUB\_CLIENT\_ID if creating new OAuth app

**Domain configuration:**

- Example: `livehub.yourdomain.com`
- Vercel provides automatic SSL certificate
- Automatic redirects from www to apex (or vice versa)

#### Performance Optimization

**Bundle size optimization:**

- Tree-shaking enabled by Next.js (automatic)
- Dynamic imports for heavy components (WebContainer loaded on dashboard only)
- Remove unused dependencies before deployment

**Loading performance:**

- Static page generation for landing page
- Client-side rendering for dashboard (requires auth)
- Lazy load WebContainer SDK until needed
- Optimize images using next/image component

**Caching strategy:**

- Static assets cached by Vercel CDN
- API responses cached in localStorage (repos, user data)
- WebContainer instance reused across previews

#### Monitoring and Analytics (Optional for MVP)

**Vercel Analytics:**

- Enable Vercel Analytics in dashboard (free tier available)
- Track page views, performance metrics
- Core Web Vitals monitoring

**Error tracking (future):**

- Sentry or similar for production error monitoring
- Track WebContainer failures, API errors
- User session replay for debugging

#### Security Headers

**Additional security headers (add to next.config.js if needed):**

```javascript
{
  key: 'X-Content-Type-Options',
  value: 'nosniff',
},
{
  key: 'X-Frame-Options',
  value: 'DENY',
},
{
  key: 'X-XSS-Protection',
  value: '1; mode=block',
},
```

**Content Security Policy (future enhancement):**

- For MVP, default CSP is sufficient
- Future: Add strict CSP for enhanced security

#### Deployment Checklist

**Before first deployment:**

- [ ] Create GitHub OAuth App and note Client ID
- [ ] Add NEXT\_PUBLIC\_GITHUB\_CLIENT\_ID to Vercel environment variables
- [ ] Verify next.config.js has required COOP/COEP headers
- [ ] Test build locally: `npm run build && npm start`
- [ ] Verify all TypeScript types are correct (no build errors)
- [ ] Test on Chrome/Edge browsers
- [ ] Push to GitHub repository

**Vercel setup:**

- [ ] Connect GitHub repository to Vercel
- [ ] Configure build settings (should auto-detect Next.js)
- [ ] Add environment variables
- [ ] Deploy
- [ ] Test deployed app with device flow authentication
- [ ] Test WebContainer boot and preview functionality
- [ ] Verify headers are correctly set (check browser DevTools)

**Post-deployment verification:**

- [ ] Can log in with GitHub device flow
- [ ] Can fetch and display repositories
- [ ] Can download and preview a repository
- [ ] WebContainer runs without errors
- [ ] Preview iframe displays correctly
- [ ] Mobile responsive layout works
- [ ] No console errors in production build
